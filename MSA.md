![MSA](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOSlEq%2FbtrlbC0nRC4%2F9Meuqs5wLwZ9DcmseMcjEK%2Fimg.png)

> `Micro Service`? **스스로 돌아 갈 수 있는 작은 서비스와, 독립적 배포 가능**
> 
> - 각각의 서비스는 크기가 작을 뿐 하나의 **모놀리식 구조**
> - 각 서비스는 **개별 프로세스**로 구동
> - **독립적 배포**가 가능
> - 다른 서비스에 대한 **의존성이 최소화**
> - REST와 같은 **가벼운 방식으로 통신**

### MicroServiceArchitecture? 🤔

📌 하나의 큰 어플리케이션을 여러 **작은 어플리케이션으로 쪼개어 변경과 조합이 가능**한 형태

- 소규모의 **독립적인 서비스로 구성되는 아키텍처 및 조직적 접근 방식**

*~SOA의 특징을 다수 공통으로 가짐~*

> SOA: 대규모 컴퓨터 시스템을 구축할 때의 개념으로, 업무상 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하고 그 서비스를 네트워크상에 연동하여 시스템 전체를 구축해 가는 방법론

### 등장 배경 🌉

💧 Monolithic Architecture? : 소프트웨어의 **모든 구성요소가 한 프로젝트에 통합**되어 있는 형태

*기존 Monolithic Architecture의 한계*

- 부분 장애가 **전체 서비스의 장애로 확대**될 수 있음
    모든 구성요소가 통합되어있기 때문에 서버트레픽이 증가하여 장애가 생기면 관련된 모든 요소에 장애가 발생
    
- 전체 시스템 **구조 파악이 어려움**
    모든 요소들이 하나의 프로젝트로 관리되기때문에 크기가 너무 커졌다.

- 빌드 시간 및 테스트, 배포 **시간의 급증**
    한번에 서비스 전체의 기능을 빌드 및 배포해야하기 때문에 시간이 늘어날 수 밖에없다.
    
- 서비스의 **특정 부분만 스케일아웃하기 어려움**
    
- **한 Framework와 언어에 종속적이다**
    *SpringFramework를 사용할 경우 서비스는 모두 SpringFramework를 사용해야한다.*

*~기존 사용하던 Monolithic Architecture의 한계점으로 인해서 MSA 등장~*

### MA와 **MSA 비교 ⚖**
![msa-micro-service-aws](https://itoutposts.com/wp-content/uploads/2022/03/Monolith-vs-Microservices-1.jpg)

 **모놀리식** 🎞
- 모든 **프로세스가 긴밀하게 결합**
- **단일 서비스**로 실행됨
- 부분 장애가 **전체 서비스 장애로 확대**
- 코드가 증가하면 **개선하기가 복잡**

**마이크로서비스** 🎡
- **독립적인** 구성 요소로 구축됨
- 각 **프로세스가 서비스**로 실행
- **경량 API**를 사용하여
**정의된 인터페이스**를 통해 통신
- **특정 기능**에 업데이트, 배포 및 확장

### 특징 🫧

> **자율성**
> - 각 구성 요소 서비스는 다른 서비스의 기능에 영향을 주지 않으면서 개발, 배포, 운영하고 확장
> - 서비스가 해당 코드 또는 구현을 다른 서비스와 공유할 필요 X
>     - 개별 구성 요소 간의 통신은 잘 정의된 API를 통해 이루어진다.
>     - api endpoint를 통해서만 상호작용하고 내부사항은 철저히 숨겨진다.

> **전문성**
> - 각 서비스는 일련의 기능을 위해 설계되며 특정 문제를 해결하는 데 중점
> - 시간이 지남에 따라 서비스에 더 많은 코드를 제공하여 서비스가 복잡해지면 더 작은 서비스로 분할

> 기술 **중립적 프로토콜을 사용**해 통신
> - 어플리케이션을 **다양한 언어와 기술**로 구축할 수 있음을 의미

> SOA에서 사용되는 **집중화된 관리 체계를 사용하지 않음**
> - ESB(Enterprise Service Bus)와 같은 **무거운 제품에 의존하지 않음**
> - REST 등 **가벼운 통신 아키텍처**, 또는 Kafka 등을 이용한 message stream을 사용
> - 각각의 서비스는 **모듈화**가 되어있으며 RPC 또는 message-driven API등을 이용하여 통신

### 장단점 🆚

👍 **장점**

> **배포**
> - 서비스별 개별 배포가 가능(배포시 전체 서비스의 중단 X)
> - 특정 서비스의 요구사항만을 반영 → 빠르게 배포 가능

> **확장**
> - 특정 서비스에 대한 확장성(scale-out)이 유리
> - 클라우드 기반 서비스 사용에 적합

> **장애**
> - 일부 장애가 전체 서비스로 확장될 가능성이 적다.
> - 부분적으로 발생하는 장애에 대한 격리가 수월

> **그 외**
> - 새로운 기술을 적용하기 유연합니다.(특정 서비스만 별도의 기술 또는 언어로 구현 가능)
> - 각각의 서비스에 대한 구조 파악 및 분석이 모놀리식 구조에 비해 쉽다.

👎 **단점**

> **설계의 어려움**
> - 모놀리식에 비해 상대적으로 많이 복잡하다.
>     - 서비스가 모두 분산되어 있어서 내부 시스템의 통신을 어떻게 가져가야 할지 정해야 한다.
>     - 통신 장애와 서버의 부하 등이 있을 경우 어떻게 transaction을 유지할지 결정하고 구현

> **성능**
> - 서비스 간 호출 시 API를 사용하므로, 통신 비용이나 Latency에 대해 이슈가 존재

> **테스트/데이터 트랜잭션**
> - 비즈니스에 대한 DB를 가지고 있는 서비스도 다르고
> 서비스의 연결을 위해서는 통신이 포함되기 때문에 트랜잭션 유지가 어렵다.
> - 통합 테스트가 어렵습니다. 개발 환경과 실제 운영환경을 동일하게 가져가는 것이 쉽지 않다.

> **데이터 관리**
> - 데이터가 여러 서비스에 분산되어 있어 조회하기 어렵다.
> - 데이터를 관리하기 어렵다.

### 구성요소 🗃

![Untitled](https://t1.daumcdn.net/cfile/tistory/993A3E465C6FA45621)

> **`API Gateway`**
> - 사용자가 접근하면 **인증 처리** 및 원하는 서비스로 **바인딩**하는 역할
> ~*API Gateway를 External Gateway로 부르기도 함*~
> 

> **`Service Mesh`**
> - Service Discovery의 **동적 서비스 확장**
> - Service Router의 **로드밸런싱**
> - Configuration의 **설정 통합 관리**
> 등등의 **API의 유입을 통제하는 중요한 기능**을 담당
> - **비즈니스 로직** 수행
> - Database or Message Broker 등의 **Backing Service로 연결**
> *~Service Mesh를 Internal Gateway라고 부르기도함~*

> **`Container`**
> - MSA가 **실제 적재**되는 container

> **`Monitoring / Logging & Tracing`**
> - 모니터링, 로깅을 위한 **Backing Service**

❓ **비즈니스 도메인**

**`비즈니스 모델`** : 소프트웨어 시스템과 관련 있는 **주요 엔티티를 식별**한 것

~*모든 엔티티는 비즈니스를 개념적으로 바라보는 관점에서 찾아야 함*~

### MSA 기반 기술 들들들
![다운로드](https://t1.daumcdn.net/cfile/tistory/997A00365C79475E04)

### MSA 상세 아키텍쳐 패턴 🧱
![99A060455C70137A29.png](https://velog.velcdn.com/post-images%2Ftedigom%2Fb6bae160-fb10-11e9-9ef4-395edd3ef4d0%2F가트너MSAComponent.png)

🔥 **관리 컨테이너**

- 개별 서비스 **인스턴스에는 작동 할 컨텍스트를 제공**
- 인스턴스 **관리 및 조정을 제공**
- 개별 인스턴스의 **생명주기를 관리**함

🔥 **외부 Gateway**

- 서비스에 대한 **액세스를 관리**
- **트래픽 관리** 및 **보안 정책을 적용**

*API 관리 제품을 사용하여 구현됨*

🔥 **서비스 메쉬 기능**

- 서비스 간의 **통신을 느슨하게 결합**
- **신뢰성 및 유연성을 유지**가 목적
- **서비스 분리, 버전 관리** 전략 지원
- 부하 시 탄성 **확장성 관리**

**`서비스 라우팅`**
- 요청(Repuest)은 **구성 및 정책에 따라 올바른 마이크로 서비스로 라우팅**해야 함

**`로드밸런싱`**
- 인스턴스의 **확정성을 위해서 필요**함
- 밸런싱의 세밀성 및 구성은 각 서비스를 관리하는 팀에 의해 제어됨

**`서비스 발견`**
- 서비스는 **느슨하게 결합 된 방식으로 검색 가능**해야 함
- 서비스 **레지스트리를 사용하여 구현**됨
- 레지스트리에서 MS 소유자는 런타임에 다른 서비스가 필요로 하는 정보를 **등록 및 구성해 찾아서 호출**

**`구성 저장소`**
- 환경의 **분산 특성으로 인해 대부분 메트릭를 사용하여 구현**됨
- 인스턴스에 MS와 전체 환경과 관련된 구성을 공유

**`ID 공급자`**
- 인스턴스는 **신뢰할 수 있는 ID를 사용하여 통신**해야 함
- 이러한 **ID를 제공하고 유효성을 검사**
- 외부 ID 공급자 또는 디렉터리와의 통합이 포함

🔥 **서비스 이미지 레지스트리**

- 사용자 환경에 **빌드 되고 테스트 된 서비스의 불변 이미지를 저장**하는 레지스트리
- 저장소에 사용되는 기술은 사용하는 배포 단위에 따라 다름

🔥 **메시지 지향 미들웨어**
- 이벤트 및 메시지 중심 패턴을 지원하기 위해 **비동기 메시징 채널이 필요**

[참고 링크 공유](https://velog.io/@tedigom/series/MSA-제대로-이해하기)
